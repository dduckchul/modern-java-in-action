# ch1. 자바 8~11 무슨 일이 벌어지고 있는가?
## 1.1 자바 역사의 흐름
* 자바 8에서 생산성의 큰 변화가 일어났다
  * 메서드 참조
    * 이전 comparator 같은 익명 클래스 구현하여 sort ->
    * ```inventory.sort(comparing(Apple::getweight))``` 
    * 위와 같은 스타일로
  * 멀티 코어의 대중화 
    * 병렬 실행을 쉽게 할수있도록 라이브러리에서 제공
    * reactive programming (webflux?)

* 스트림 Api
* 메서드에 코드를 전달하는 기법 (메서드 참조)
* 인터페이스의 디폴트 메서드

## 1.2 왜 아직도 자바는 변환하는가
* c나 c++ 은 런타임이 가볍기때문에 아직 많이쓰임
* 그러나 런타임 환경이 여유있는 환경에서는 안정적인 프로그램을 더 선호함
  * 기계의 시간보다 프로그래머의 시간이 더 소중하다는 생각?

### 자바 8 이후의 변화들
* 객체 지향으로 잘 짜여진 라이브러리들이 있어서 처음에 유입이 쉬웠다
* JVM에서 바이트코드로 컴파일 한후 실행되는 특징으로, JVM만 쓰는 언어들도 존재
* 빅데이터의 발전으로 병렬실행 할수있는 코드들이 중요해짐
* 자바 8에서 병렬성 코드들을 잘 지원해주었다~
* 아래 요소들이 자바 8의 변화를 잘 보여줌

### 스트림 프로세싱
* 한번에 한 항목만을 처리했지만 이제 스트림을 통해 병렬로 실행할수 있게됨
  * ex) 리눅스의 cat | sort | tail 이 하나씩 수행되는게 아니라 병렬로
  * java.util.stream 패키지를 통해 스트림 api 지원
  * 어렵게 쓰레드를 쓰지 않아도 병렬성을 사용 가능하다.

### 동작 파라미터화로 코드 전달
* 연산의 동작 (behavior)를 파라미터로 전달할 수 있다
* 함수형 프로그래밍의 중요한 개념

### 병렬성과 공유 가변 데이터
* 병렬성을 공짜로 얻을수 있다고 하는데 그대신 포기해야하는것들?
* 다른 코드와 동시에 실행해도 안전하게 실행될수 있어야됨
  * 공유된 가변 데이터에 접근하면 안된다
  * 기존처럼 synchronized 키워드를 사용해도 되겠지만, 일반적으로 성능에 악영향을 끼친다. (병렬성 포기하고 순차적으로 실행되어야 하기 때문)

### 자바가 진화해야 하는 이유
* 고전적인 객체지향에서 벗어나 함수형 프로그래밍을 지원

## 1.3 자바의 함수
* 프로그래밍에서의 함수? 보통 메서드
* functional programming 에서는 수학적인 의미의 함수도 포함
* 1급 시민, 2급 시민의 개념
  * 값을 전달할 수 있는것 1급 시민,
  * 자바에서는 그 외 모든 객체, 클래스 등은 2급 시민
* 자바 8에서 2급 값을 1급 값으로 바꿀수 있는 기능 만듦

### 메서드와 람다를 1급 시민으로
* 그루비, 스칼라의 예에서처럼 메서드를 전달할수 있으면 갖는 장점이 있다.
* 메서드 참조
  * :: 이 메서드를 값으로 사용해라 를 통해, 직접 전달한다.
* 람다 : 익명함수
  * (int x) -> x + 1 와 같이 함수를 새로 선언하지 않아도 전달 가능
  * 굳이 따로 구현해야되나? 라는 클래스들을 더 간결하게 구현 가능

### 메서드 전달 코드 예제
```
// as-is
public static List<Apple> filterGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if ("green".equals(apple.getColor())) {
        result.add(apple);
      }
    }
    return result;
  }

// to-be
List<Apple> greenApples = filterApples(inventory, FilteringApples::isGreenApple);
```

### 메서드 전달에서 람다로
```
List<Apple> heavyApples2 = filterApples(inventory, (Apple a) -> a.getWeight() > 150);
List<Apple> weirdApples = filterApples(inventory, (Apple a) -> a.getWeight() < 80 || "brown".equals(a.getColor()));
```
* 한두번만 사용할 메서드들을 다 정의하지 않아도됨
* 람다가 너무 길어진다면 가독성을 해치므로 메서드 참조를 활용하는게 바람직

### 스트림 Api
* 자바의 거의 대부분 프로그램들은 컬렉션을 만들고 활용
* 기존 코드들은 필터링, 그루핑 할때 엄청 많은 기본 코드들을 요함
* 스트림 api에서 그 문제들을 해결
```
transactions.stream().filter().collect(groupingby())
```
* 스트림 api에서는 라이브러리 내부에서 반복문이 처리됨

* 엄청나게 많은 요소들이 있다면?
* 위와 같은 컬렉션에 스트림 api 병렬로 사용하여 해결

### 멀티 스레딩의 어려움
* 스레드를 잘 제어하지 못하면 원치 않은 방식으로 데이터가 처리된다
* 공유된 데이터에 접근하면 그렇게 될 가능성 매우 높음
* 자바 8의 스트림 api를 통하면 컬렉션 처리하면서 나타나는 모호함과 반복적인 코드들을 없엘수 있고, 병렬성을 처리하기 쉬워짐
  * ex) 반복적으로 필터링, 그루핑, 추출
* fork & join 통해 병렬성 챙기기 쉬워짐
* 병렬성 필요한곳에 필요한 코드는 하나 .stream().parallelStream()

### 1.5 디폴트 메서드와 자바 모듈
* 최근은 만들어진 외부 컴포넌트를 활용하여 시스템을 구축하는 경향이 크다.
* 모듈 시스템은 모듈을 정의하는 문법을 제공, 패키지 모음을 포함하는 모듈을 정의할 수 있다.
* 모듈 덕에 Jar같은 컴포넌트에 구조를 적용할수 있고, 문서화와 모듈 확인 작업이 용이해짐
* 인터페이스를 쉽게 바꿀 수 있도록 디폴트 메서드를 제공
* ex) list 컬렉션에 추가된 sort 디폴트 메서드
```
default void sort(Comparator<? super E> c){
    Collections.sort(this, c)    
}
```
* 이것에 대한 이점 -> 모든 sort 필요한 클래스가 sort를 구현해야했지만, 자바 8 이후부턴 안해도됨

### 1.6 함수형 프로그래밍에서 가져온 다른 아이디어
1. 메서드와 람다의 일급 시민으로 사용
2. 가변 공유 상태가 없는 병렬 실행 하여 안전하게 메서드 호출
3. 널 포인터 회피할 수 있는 Optional 클래스
4. 패턴 매칭