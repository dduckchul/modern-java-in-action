# 스트림 소개
## 스트림이란 무엇인가?
* 스트림을 이용하면 선언형으로 컬렉션 데이터를 처리할 수 있다.
  * 루프, if 조건문 제어 블록 필요 없이 동작의 수행을 지정할 수 있다.
* 멀티쓰레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다.
* filter, sorted, map, collect 같은 빌딩 블록 연산을 연결하여 복잡한 데이터 처리 파이프 라인을 만들 수 있다.
* 여러 파이프 라인으로 연결해도 가독성과 명확성이 유지된다
* filter 와 같은 연산은 고수준 빌딩 블록으로 이루어져 있으므로, 특정 쓰레딩 상황에 제한되지 않고 어떤 상황에서든 사용할 수 있다.
* 결과적으로 데이터 처리 과정을 병렬화 하면서 스레드와 락을 걱정할 필요가 없다
* streamAPI는 매우 비싼 연산이다.

## 스트림 시작하기
* 자바 8 컬렉션에서는 스트림 반환하는 stream 메서드가 추가되었다.
* 스트림 메서드 이외에도 숫자 범위나 I/O 자원에서 스트림을 만드는 등 다양한 방법으로 스트림을 얻을 수 있다.
* 스트림의 정의 - 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소
  * 연속된 요소 
    * 컬렉션과 마찬가지로 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다.
    * 컬렉션은 자료 구조 이므로 컬렉션에서는 시간과 공간의 복잡성과 관련한 요소 저장 및 접근 연산이 주를 이룬다.
    * 스트림은 filter, sorted, map 처럼 표현 계산식이 주를 이룬다.
    * 컬렉션의 주제는 데이터, 스트림의 주제는 계산이다.
  * 소스 (Source)
    * 스트림은 컬렉션, 배열, I/O자원 등의 데이터 제공 소스로부터 데이터 소비
    * 리스트로 스트림을 만들면 스트림의 요소는 리스트의 요소와 같은 순서 유지
  * 데이터 처리 연산
    * 스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다.
    * Ex) filter, map, reduce, find, match, sort 등등..

* 스트림의 주요한 특징
  * 파이프라이닝
    * 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프 라인을 구성할 수 있도록 스트림 자신을 반환한다. 연산 파이프라인은 데이터 소스에 적용하는 데이터 베이스 질의와 비슷하다.
  * 내부 반복
    * 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 내부 반복을 지원한다.

## 스트림과 컬렉션
* 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다.
* 스트림과 컬렉션의 가장 큰 차이는 데이터를 언제 계산하느냐
* 컬렉션은 연재 자료구조가 포함하는 모든 값을 메모리에 저장한다.
  * 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다.
  * 이런 연산 수행할 때마다 컬렉션의 모든 요소를 메모리에 저장해야함.
* 스트림은 이론적으로 요청할때만 요소를 계산한다
  * 스트림에 요소를 추가하거나 요소를 제거할 수 없다.
  * 사용자가 요청하는 값만 스트림에서 추출한다
  * 결과적으로 프로듀서와 컨슈머 관계를 형성한다.

* 스트림은 게으르게 만들어지는 컬렉션과 같다 (사용자가 데이터 요청할때만 생성)
* 컬렉션은 적극적으로 생성된다 -> 컬렉션은 끝이 없는 소수를 모두 포함하려함

## 딱 한번만 탐색 할 수 있다.
* 한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다. (데이터 소스가 I/O 채널이라면 소스를 반복 사용할 수 없으므로 새로운 스트림을 만들 수 없다)
``` java
List<String> title = Arrays.asList("Java8", "In", "Action");
Stream<String> s = title.stream();
s.forEach(System.out::println); // Java8 in action 출력
s.forEach(System.out::println); // 스트림 닫혔다는 익셉션 발생
```

## 외부 반복과 내부 반복
* 컬렉션 인터페이스 사용하려면 사용자가 직접 요소를 반복한다 (for-each등)
* 스트림 라이브러리는 내부반복을 사용한다.
* 스트림은 내부 반복을 사용하므로 반복과정을 신경쓰지 않아도 된다.
* 하지만 이점을 누리려면 filter, map등과 같이 반복을 숨겨주는 연산 리스트가 미리 정의 되어 있어야 한다.
* 반복을 숨겨주는 대부분의 연산은 람다 표현식을 인수로 받으므로 동작 파라미터화를 사용할 수 있다.

## 스트림 연산
* 스트림 인터페이스의 연산을 크게 두가지로 구분할 수 있다.
  * 중간 연산 - 연결할 수 있는 스트림 연산
  * 최종 연산 - 스트림을 닫는 연산

* 중간연산
  * filter나 sorted는 다른 스트림을 반환한다.
  * 여러 중간 연산을 연결하여 질의를 만들 수 있다.
  * 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다는 점 (lazy binding)
  * 중간 연산을 합친 다음에 합쳐진 중간 연산을 최종연산으로 최종 처리
  * 레이지 바인등으로 몇가지 최적화를 얻을 수 있음
    * 쇼트 서킷, 루프 퓨전

* 최종 연산은 스트림 파이프라인에서 결과를 도출
  * List, Integer, void 등 스트림 이외의 결과가 반환

* 스트림 이용하기
  * 질의를 이용할 데이터 소스
  * 스트림 파이프라인을 구성할 중간 연산 연결, filter, map, limit, 등등
  * 스트림 파이프라인을 실행하고 결과를 만들 최종 연산 forEach, collect count

## 정리
* 스트림은 소스에서 추출된 연속 요소로 데이터 처리 연산을 지원
* 스트림은 내부 반복을 지원 (filter, map, sorted 등의 연산으로 반복 추상화)
* 스트림에는 중간 연산과 최종 연산이 있다.
* 중간 연산은 filter와 map 처럼 스트림을 반환하면서 다른 연산과 연결되는 연산, 중간 연산을 이용하여 파이프 라인을 구성할 수 있으나, 어떤 결과도 생성 할 수 없다.
* forEach나 count 처럼 스트림 파이프라인을 처리하여 스트림 아닌 결과를 반환하는 연산을 최종연산이라 한다.
* 스트림의 요소는 요청할때 게으르게 계산된다 (lazy binding)

