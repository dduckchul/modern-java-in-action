# 병렬 데이터 처리와 성능
* 자바 8 이후 포크/조인 프레임워크 + 쉬운 스트림 병렬 처리로 인해 병렬처리 매우 쉬워졌다.

## 병렬 스트림
* 각각의 쓰레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림
* 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다.

### 순차 스트림을 병렬 스트림으로 변환하기
* 순차 스트림에 parallel 메서드를 호출하면 기존의 함수형 리듀싱 연산이 병렬로 처리된다
``` java
public long parallelSum(long n) {
    return Steram.iterate(1L, i -> i + 1)
    .limit(n)
    .parallel()
    .reduce(0L, Long::sum)
}
```
* 리듀싱 연산을 여러 청크에 병렬로 수행 할 수 있다.
* sequential 로 병렬 스트림을 순차 스트림으로 바꿀 수 있다.
* 두 메서드를 이용해 어떤 연산을 병렬로 실행하고 어떤 연산을 순차로 실행할지 제어할 수 있다.

#### 병렬 스트림에서 사용하는 쓰레드 풀 설정
* 기본적으로는 ForkJoinPool을 사용한다.
* 포크조인풀은 프로세서 수 (Runtime.getRuntime().availableProcessors()) 에 상응하는 쓰레드를 갖는다.

### 스트림 성능 측정
* 성능 최적화에는 꼭 측정을 해바야한다!
* 자바 마이크로 벤치마크 하니스 (JMH) 이용해 작은 벤치마크 구현가능
* 코드 예제의 벤치마크 결과
```
Benchmark                                  Mode  Cnt   Score   Error  Units
ParallelStreamBenchmark.iterativeSum       avgt    4   3.202 ± 0.325  ms/op
ParallelStreamBenchmark.parallelRangedSum  avgt    4   0.607 ± 0.136  ms/op
ParallelStreamBenchmark.parallelSum        avgt    4  52.663 ± 6.513  ms/op
ParallelStreamBenchmark.rangedSum          avgt    4   3.249 ± 0.127  ms/op
ParallelStreamBenchmark.sequentialSum      avgt    4  51.872 ± 2.454  ms/op
```
* Stream.iterate()는 본질적으로 순차적일수밖에 없기때문에, 그냥 parallel()쓰면 느리다.
* 각각의 합계가 다른 쓰레드에서 실행되었지만, 결국 순차 처리 방식과 크게 다른점이 없으므로 쓰레드 할당하는 오버헤드만 증가한다.

#### 더 특화된 메서드 사용
* 멀티코어 프로세스 활영하여 합계 연산을 병렬로 실행하려면..?
* LongStream.rangeClosed()
* 기본형 long을 직접 사용하므로 박싱, 언박싱 오버헤드가 사라진다.
* LongStream.rangeClosed는 쉽게 청크로 분할 할 수 있는 숫자 범위를 생산한다. (ex -> 1~20 : 1~5, 6~10, 11~15, 16~20)
* rangedSum() vs sequentialSum() -> 언박싱 / 박싱 오버페드
* rangedSum() vs parallelRangedSum() -> 순차 vs 병렬 수행
* 그러나 병렬화가 완전 공짜는 아님
  * 스트림을 재귀적으로 분할
  * 서브스트림을 리듀싱 연산으로 할당
  * 결과를 하나의 값으로 합쳐야 한다.
  * 멀티코어간 데이터 이동은 생각보다 비싸다.
  * 코어간 데이터 전송시간보다 훨씬 오래 걸리는 작업만 병렬로 다른 코어 에서 수행할 것
* 병렬 스트림의 올바른 사용법
  * 공유된 상태를 바꾸는 알고리즘 사용할 경우 안됨

### 병렬 스트림 효과적으로 사용하기
* 양적으로 병렬으로 사용할지 아닐지는 적절하지 않음.
  * 정해진 기기에서 정해진 연산을 수행할 때는 이와 같은 기준을 사용할 수 있지만, 사용이 달라지면 제 역할을 하지 못한다
1. 확신이 서지 않으면 직접 측정하라
  * 순차 스트림을 병렬로 쉽게 바꿀수 있음
  * 무조건 병렬 스트림 바꾸는것이 능사는 아니다.
  * 언제나 병렬로 변경하는것이 빠른것은 아니기 때문
  * 병렬로 수행할때는 투명하지 않을때가 많다.
2. 박싱을 주의하라
  * 자동박싱, 언박싱은 성능 크게 저하시킬 수 있다.
  * 기본형 특화 스트림을 많이 이용할것 (intStream, LongStream...)
3. 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다.
  * 특히 limit, findFirst 처럼 순서에 의존하는 연산이 병렬이면 비싼 비용이 든다.
  * findAny는 순서와 상관없으므로 findFirst 보다 좋음
  * 정렬된 스트림에 unordered호출하면 비정렬된 스트림을 얻을 수 있다.
  * 스트림에 N개 요소 있을때 순서 상관없다면, 비정렬된 스트림에 limit 호출하는것이 효율적이다.
4. 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라
  * 처리해야할 요소 수가 N이고 하나의 요소를 처리하는데 드는 비용을 Q라고 하면, 전체 스트림 파이프라인 처리 비용을 N*Q로 예상할 수 있다. Q가 높아지는것은 병렬 스트림으로 성능 개선할 수 있다
5. 소량의 데이터에서는 병렬 스트림이 도움 되지 않는다.
  * 소량의 데이터를 처리하는 상황에서는 병렬화 과정에서 생기는 부가 비용을 상쇄할 수 있을 만큼의 이득을 얻지 못함 (쓰레드 할당, 코어간 데이터 전송시간)
6. 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다.
  * Sized 스트림은 정확히 같은 크기의 두 스트림으로 분할 할 수 있으므로, 효과적으로 스트림 병렬 처리 할 수 있다.
  * 필터 연산이 있으면 스트림의 길이를 예측할 수 없으므로 효과적으로 스트림을 병렬 처리할 수 있을지 없을지 모름.
7. 최종 연산과의 병합과정 (ex) Collector의 combiner 메서드 비용을 살펴볼것, 병합 과정 비용이 비싸다면 병렬 스트림으로 얻는 성능 이익이 서브스트림 합치는 과정에서 상쇄될 수 있음

* 병렬 스트림이 수행되는 내부 인프라 구조도 살펴봐야 한다.
* 자바 7에서 추가된 포크/조인 프레임워크로 병렬 스트림이 처리된다.

## 포크/조인 프레임워크
* 병렬화 할 수 있는 작업을 재귀적으로 작은 작업으로 분할, 서브 태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계되었다.

### RecursiveTask\<R> 활용
* 쓰레드풀 이용하려면 RecursiveTask\<R>의 서브 클래스를 만들어야 한다.
* RecursiveTask를 정의하려면 compute를 구현해야함.
* divide and conquer 알고리즘의 병렬화 버전
* 자세한건 예제 소스코드로 보세요~~
* 일반적으로 어플리케이션에서는 둘 이상의 ForkJoinPool을 사용하지 않는다.

### 포크/조인 프레임워크를 제대로 사용하는 방법
* join 메서드를 태스크에 호출하면 태스크가 생산하는 결과가 준비될 때 까지 호출자를 block 시킨다.
 * 따라서 두 서브태스크가 모두 시작된다음에 join()을 시작해야 한다.
* RecursiveTask 내에서는 ForkJoinPool의 invoke를 사용하면 안된다. 대신 compute나 fork메서드를 직접 호출 할 수 있다.
  * 순차 코드에서 병렬 계산을 시작할 때만 invoke를 사용한다.
* subTask에 fork 메서드를 호출해서 ForkJoinPool의 일정을 조절할 수 있다.
  * 왼쪽 작업과 오른쪽 작업 모두에 fork 메서드를 호출 하는것이 자연스러운 수 있지만, 한쪽 작업에는 compute를 호출하는것이 효율적.
    * 위에처럼 하면 서브 태스크의 한 태스크에는 같은 쓰레드를 재사용 할 수 있으므로, 풀에서 불필요한 태스크 할당하는 오버헤드 피할 수 있다.
* 포크/조인 프레임워크 병렬 계산은 디버깅하기 어렵다
  * fork라 불리는 다른 쓰레드에서 compute를 호출하므로 스택트레이스가 도움이 안되는경우 많음
* 순차 처리보다 무조건 빠를 생각을 버려라
  * 각 서브 태스크의 실행시간이 새로운 태스크 포킹하는데 드는 시간보다는 길어야 한다.

* 포크/조인 분할 전략에서는 주어진 서브태스크를 더 분핧할 것인지 결정할 기준을 정해야 한다.

### 작업 훔치기
* 위 예제에서는 만개 이하면 서브태스크로 나누지 않았다, 더 좋은 기준을 찾을 수 있는 방법은..?
* 코어 갯수가 보통 한정되어있는데 수천개 크기의 태스크로 나누는게 의미가 있을까 싶지만..? 보통 작은 단위로 나누는게 성능이 좋음!
  * 작업 훔치기 (work-stealing)가 존재함
  * 위 기법에서는 모든 스레드를 거의 공정하게 분할한다.
  * 자신에게 할당된 태스크를 포함하는 이중 연결 리스트를 참조하면서, 작업이 끝날때 마다 큐의 헤드에서 다른 태스크를 가져와서 작업을 처리한다.
  * 할일이 없어진 쓰레드는 유휴 상태로 바뀌는 것이 아니라 다른 쓰레드 큐의 꼬리에서 작업을 훔쳐온다.

## Spliterator 인터페이스
* 자바 8에서 제공하는 새로운 인터페이스
* 분할 할 수 있는 반복자
* 분할 로직을 개발하지 않고도 병렬 스트림을 이용할 수 있다.
* 자바 8부터는 컬렉션 프레임 워크에 포함된 모든 자료구저에 사용할수 있는 디폴트 Spliterator 구현을 제공한다.
``` java
public interface Spliterator<T> {
    boolean tryAdvance(Consumer<? super T> action);
    Spliterator<T> trySplit();
    long estimateSize();
    int characteristics();
}
```
* T는 탐색하는 요소
* tryAdvance는 순차 소비하면서 탐색할 요소 있으면 true 반환 (Iterator)
* trySplit은 일부 요소를 분할해서 두번째 Spliterator를 생성
* estimateSize()는 탐색해야할 요소 수 정보를 제공
  * 더 쉽고 공평하게 분할 할 수 있다.

### 분할 과정
* 스트림을 분할하는 과정은 재귀적으로 일어남
* 1단계에서 Spliterator에 trySplit호출하면 두번째 Spliterator가 생성된다.
* 2단계에서 다시 trySplit 호출하면 4개 생성
* trySplit결과가 null 될떄까지 반복한다.
* trySplit -> null일 경우 더이상 분할할 수 없는 자료구조임

### spliterator 특성
* characteristics 메서드로 정의하는 특성, 추상 메서드
* 컬렉터와 개념상 비슷하지만 다른 방식으로 정의되어있음.

| 특성 | 의미 |
| --- | --- |
| ORDERED | 리스트처럼 순서 있음. 순서에 유의 |
| DISTINCT | x,y 두 요소를 방문했을때 x.equals(y)는 항상 false |
| SORTED | 탐색된 요소는 미리 정의된 정렬 순서를 따름 |
| SIZED | 크기가 알려진 소스로 생성했으므로, 정확한 값을 반환 |
| NON-NULL | 탐색하는 모든 요소가 non-null |
| IMMUTABLE | 소스가 불변 |
| CONCURRENT | 동기화 없이 여러 스레드에서 고칠 수 있다 |
| SUBSIZED | 분할되는 모든 Spliterator가 Sized 특성 가진다 |


### 함수형으로 단어 수를 세는 메서드 재구현
1. String을 스트림으로 변환 (기본형은 int, long, double만 제공하므로 Stream\<Character> 사용해야함)
``` java
Stream<Character> stream = IntStream.range(0, SENTENCE.length()).mapToObj(SENTENCE::charAt);
```
2. 단어수 저장하는 int, 공백 여부 기억하는 boolean 변수등 두가지 변수가 필요, WordCounter 객체 생성
  * accumulate 메서드는 WordCounter 상태를 어떻게 바꿀 것인지, 정확하게는 WordCounter 클래스를 어떻게 생성할 것인지를 정의한다. (WordCounter는 불변 클래스 이므로)
  * 스트림을 탐색하면서 새로운 문자를 찾을때마다 accumulate메서드를 호출한다.
  * 자세한 예제는 코드로 보도록~~

3. 이후 문자 스트림의 리듀싱 연산을 구현
``` java
WordCounter wordCounter = stream.reduce(
    new WordCounter(0, true),
    WordCounter::accumulate,
    WordCounter::combine);
```

### WordCounter 병렬로 수행하기
* 위와 같은 클래스, 리듀싱 연산 만든 이유는? 병렬로 수행하기 위해..
* 위에서 단순하게 패러럴로 돌리면 잘못된 숫자가 나옴..?
  * Why? 단어가 끝나는 (공백문자) 지점에서 나누는게 아니므로, 원하지 않게 단어 중간에서 짤리면 단어가 중복해서 세어진다.
  * 이때 위에서 배운 Spliterator 구현해서, 공백문자에서만 나눠지도록 구현한다.
  * 분할이 필요한 상황에서는 파싱해야할 문자열 청크의 중간 위치를 기준으로 분할하도록 지시.
  * 단어 중간을 분할하지 않도록 빈 문자가 나올때까지 분할 위치를 이동한다.
  * 분할할 위치를 찾았으면 새로운 splitator을 만들다.
* 탐색할 요소의 개수 (estimatedSize)는 파싱할 문자열 전체 길이와 반복중인 위치의 차이
* charateristic 메서드는 ORDERED, SIZE, SUBSIZED, NONNULL, IMMUTABLE임.

### 정리
* 내부 반복을 이용하면 명시적으로 다른 스레드를 사용하지 않고도 스트림을 병렬 처리 할 수 있다.
* 스트림을 병렬로 처리 할 수 있지만 항상 빠른건 아니다.
* 병렬처리는 동작방법과 성능이 직관적이지 않으므로 성능을 직접 측정해봐야 한다
* 병렬 스트림으로 데이터 집합을 병렬 실행할 때 특히 처리해야 할 데이터가 아주 많거나 각 요소를 처리하는 데 오랜 시간이 걸릴 때 성능을 높일 수 있다.
* 가능하면 기본형 특화 스트림을 사용하는 등 올바른 자료구조 선택이 어떤 연산을 병렬로 처리하는 것보다 성능적으로 더 큰 영향을 미칠 수 있다.
* 포크/조인 프레임워크에서는 병렬화 할 수 있는 태스크를 작은 태스크로 분할한 다음에 분할된 태스크를 각각의 스레드로 실행하며 서브태스크 각각의 결과를 합쳐서 최종 결과를 생성한다.
* Splitator는 탐색하려는 데이터를 포함하는 스트림을 어떻게 병렬화 할것인지 정의한다.