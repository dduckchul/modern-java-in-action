# 자바 8,9,10,11 : 무슨 일이 일어나고 있는가 ?

## 1.1 역사의 흐름은 무엇인가 ?
* 자바 역사를 통틀어 가장 큰 변화가 자바 8에서 일어남
```
// 고전적 코드
Collections.sort(inventory, new Comprator<Apple>() {
	public int compare(Apple a1, Apple a2) {
    	return a1.getWeight().compareTo(a2.getWeight());
        }
 });
```
```
// 자바 8에서의 구현 방식
inventory.sort(comparing(Apple::getWeight));
```
* 자바는 병렬 실행 환경을 쉽게 관리하고 에러가 덜 발생하는 방향으로 진화하려 노력
* 자바 8에서는 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법 제공

### 자바 8에서 제공하는 새로운 기술
1. 스트림 API
    * 스트림 API는 최적의 저수준 실행 방법을 선택하는 방식으로 동작 
      -> 에러를 자주 일으키며 멀티코어 CPU를 이용하는 것보다 비용이 훨씬 비싼 키워드 synchronized를 사용하지 않아도 됨
    * 스트림 API 덕분에 메서드에 코드를 전달하는 간결 기법(메서드 참조와 람다)과 인터페이스의 디폴트 메서드가 존재할 수 있음 
2. 메서드에 코드를 전달하는 기법
    * 함수형 프로그래밍에서 위력을 발휘
3. 인터페이스의 디폴트 메서드

## 1.2 왜 아직도 자바는 변화하는가 ?
* 처음부터 자바는 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작
* JVM의 최신 업데이트 덕분에 경쟁 언어는 더 부드럽게 실행될 수 있으며, 자바와 상호동작할 수 있게 됨
* 빅데이터라는 도전에 직면하면서 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해서 빅데이터를 효과적으로 처리할 필요성이 높아짐
*  -> 병렬 프로세싱 활용해야하는데, 지금까지의 자바로는 충분히 대응 불가
*  자바 8은 더 다양한 프로그래밍 도구 그리고 다양한 프로그래밍 문제를 더 빠르고 정확하며 쉽게 유지보수 할 수 있다는 장점 제공

### 1.2.2 스트림 처리
* 자바 8에는 java.util.stream.패키지에 스트림 API가 추가됨
   * 기존에는 한 번에 한 항목을 처리했지만, 우리가 하려는 작업을 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있음
   * 스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 병렬성 얻을 수 있음
 
### 1.2.3 동작 파라미터화로 메서드에 코드 전달하기
* 자바 8에서는 메소더(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능 제공 -> 동작 파라미터화
   * 스트림 API는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초하기 때문에 중요
 
### 1.2.4 병렬성과 공유 가변 데이터
* 병렬성 얻으려면 ? 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 한다
* 다른 코드와 동시에 실행하더라도 안전하게 실행 할 수 있는 코드를 만들려면 공유된 가변 데이터에 접근하지 않아야 함
   -> 순수함수, 부작용 없는 함수, 상태 없는 함수

### 1.2.5 자바가 진화해야 하는 이유
* 고전적인 객체지향에서 벗어나 함수형 프로그래밍으로 다가섬
* 어떤 문제를 더 효율적으로 해결할 수 있는 다양한 도구를 얻게 된 것

## 1.3 자바 함수
* 자바 함수 = 정적 메서드 + 수학적인 함수처럼 사용됨
* 자바 8 에서는 함수를 새로운 값의 형식으로 추가
   * 멀티코어에서 병렬 프로그래밍을 활용할 수 있는 스트림과 연계될 수 있도록 함수 만들었기 때문
* 런타임에 메서드를 전달할 수 있도록

### 메서드 참조
* 메서드 참조 ::를 이용해서 직접 전달할 수 있음
```
// 메서드를 통한 파일 필터링
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
    public boolean accept(File file) {
        return file.isHidden();
    }
});
```
```
// 메서드 참조를 이용한 파일 필터링
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

### 람다:익명 함수
* (int x) -> x+1 즉 x라는 인수 호출하면 x+1을 반환하는 동작 수행하도록 코드 구현 가능
* 이용할 수 있는 편리한 클래스나 메서드가 없을 때 새로운 람다 문법을 이용하면 더 간결하게 코드 구현 가능

## 1.4 스트림
* 스트림 API를 이용하면 컬렉션 API는 상당히 다른 방식으로 데이터를 처리할 수 있음
* 외부 반복 : for-each 루프를 이용해서 각 요소를 반복하면서 작업 수행
* 내부 반복 : 스트림 API에서는 라이브러리 내부에서 모든 데이터가 처리됨

### 1.4.1 멀티스레딩은 어렵다
* 컬렉션을 필터링할 수 있는 가장 빠른 방법
   * 컬렉션 -> 스트림 -> 병렬로 처리 -> 리스트로 다시 복원
* .stream() : 순차처리
* .parallelStream() : 병렬 처리

## 1.5 디폴트 메서드와 자바 모듈
* 인터페이스를 쉽게 바꿀 수 있도록 디폴트 메서드를 지원
```
default void sort(Comparator<? super E> c) {
	Collections.sort(this, c);
}
```
## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어
* Optional<T> 클래스 : NullPointer 예외 피할 수 있도록 도와줌
* 구조적 패턴 매칭 기법



